# Todo: translate comments, names of variables and functions.
# Todo: check PEP 8
# Todo: explain functions

# -*- coding: utf-8 -*-
"""Escoamento_Cilindro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YcVG8rK2mb4ev6HzqJRqQxfbhPane8Ub
"""

import numpy as np
# import matplotlib.pyplot as plt


class PressureMatrix:
    def __init__(self, NZ, NTETA, NRAIO, NintervZ, NintervTETA, NintervRAIO, Lb, Lteta, DZ, DTETA, NTOTAL,
                              omega, Pent, Ps, raioVale, raioCrista, Ro, lOnda, Xe, Ye, visc, Rho):
        self.NZ = NZ
        self.NTETA = NTETA
        self.NRAIO = NRAIO
        self.NintervZ = NintervZ
        self.NintervTETA = NintervTETA
        self.NintervRAIO = NintervRAIO
        self.Lb = Lb
        self.Lteta = Lteta
        self.DZ = DZ
        self.DTETA = DTETA
        self.NTOTAL = NTOTAL
        self.omega = omega
        self.Pent = Pent
        self.Ps = Ps
        self.raioVale = raioVale
        self.raioCrista = raioCrista
        self.Ro = Ro
        self.lOnda = lOnda
        self.Xe = Xe
        self.Ye = Ye
        self.visc = visc
        self.Rho = Rho

    def calculate_pressure_matrix(self):
        self.CalculaCoeficientes()
        M, f = self.MontaMatriz()
        P = self.ResolveMatriz(M, f)
        return self.Pmatriz(P)

    def CalculaCoeficientes(self):
        self.C1 = np.zeros([self.NZ, self.NTETA])
        self.C2 = np.zeros([self.NZ, self.NTETA])
        self.C0W = np.zeros([self.NZ, self.NTETA])
        self.RE = np.zeros([self.NZ, self.NTETA])
        self.RI = np.zeros([self.NZ, self.NTETA])
        self.Z = np.zeros([1, self.NZ])

        # Montando as matrizes de cada coeficiente:
        for i in range(self.NZ):
            zno = (i) * self.DZ  # mudei de i-1 parea i devido à contagem do Python
            self.Z[0][i] = zno
            # Meu Z deve ficar Z=[0*DZ,1*DZ,2*DZ,...,(NZ-1)*DZ]
            for j in range(self.NTETA):
                tetano = (j) * self.DTETA  # mudei de j-1 para j pela mesma razão
                [raioExterno, Xre, Yre] = self.FuncaoRaioExterno(tetano)
                [raioInterno, Xri, Yri] = self.FuncaoRaioInterno(zno, tetano)

                # Plota um corte em Z=0:
                # if i == 0:
                #     plt.plot(Xre, Yre, '.')
                #     plt.plot(Xri, Yri, '.')
                #     plt.plot(0, 0, '*')
                #     plt.title('Corte no plano Z=0')

                w = (self.omega) * raioInterno

                K = (1. / (raioInterno ** 2 - raioExterno ** 2)) * ((raioExterno ** 2) * (-(1. / 2)
                                                                                          + np.log(raioExterno)) - (
                                                                            raioInterno ** 2) * (
                                                                            -(1. / 2) + np.log(raioInterno)))

                self.C1[i][j] = (1. / (4 * self.visc)) * ((raioExterno ** 2) * (np.log(raioExterno))
                                                - (raioInterno ** 2) * (np.log(raioInterno))
                                                + (raioExterno ** 2 - raioInterno ** 2) * (K - 1))
                - ((raioExterno ** 2) / (2 * self.visc)) * ((np.log(raioExterno) + K - 1 / 2)
                                                       * np.log(raioExterno / raioInterno))

                self.C2[i][j] = - ((raioInterno ** 2) / (8. * self.visc)) * ((raioExterno ** 2
                                                                    - raioInterno ** 2 - (raioExterno ** 4
                                                                                          - raioInterno ** 4) / (
                                                                            2 * (raioInterno ** 2)))
                                                                   + ((raioExterno ** 2 - raioInterno ** 2) / (
                                (raioInterno ** 2)
                                * (np.log(raioExterno / raioInterno)))) * ((raioExterno ** 2)
                                                                           * np.log(raioExterno / raioInterno)
                                                                           - (
                                                                                   raioExterno ** 2 - raioInterno ** 2) / 2.))

                self.C0W[i][j] = - (w * raioInterno) * (((np.log(raioExterno / raioInterno))
                                                    * (1 + (raioInterno ** 2) / (raioExterno ** 2
                                                                                 - raioInterno ** 2))) - (1. / 2))

                self.RE[i][j] = raioExterno

                self.RI[i][j] = raioInterno

    def FuncaoRaioExterno(self, tetano):
        e = np.sqrt(self.Xe ** 2 + self.Ye ** 2)
        if (self.Xe > 0. and self.Ye >= 0.) or (self.Xe > 0 and self.Ye < 0):
            # Betha é o ângulo que a excentricidade se encontra:
            betha = np.arctan(self.Ye / self.Xe)
        if (self.Xe < 0. and self.Ye <= 0.) or (self.Xe < 0 and self.Ye > 0):
            betha = -np.pi + np.arctan(self.Ye / self.Xe)
        if self.Xe == 0.:
            if self.Ye > 0.:
                betha = np.pi / 2.
            else:
                betha = -np.pi / 2.
        # Alpha é o ângulo entre TETA e a excentricidade (betha):
        alpha = tetano - betha
        raioExterno = e * np.cos(alpha) + np.sqrt(self.Ro ** 2 - (e * np.sin(alpha)) ** 2)
        Xre = raioExterno * np.cos(tetano)
        Yre = raioExterno * np.sin(tetano)
        return raioExterno, Xre, Yre

    def FuncaoRaioInterno(self, z, tetano):
        # Caso Cilindrico:
        raioInterno = self.raioVale

        # Caso Cônico:
        # raioInterno= raioVale + ((raioCrista - raioVale)/Lb)*z

        # Caso Senoidal:
        # raioInterno= (raioVale + raioCrista)/2. + ((raioCrista-raioVale)/2.)*np.sin((2*np.pi/lOnda)*z + np.pi/2.)

        # Caso onda quadrada: (olhar com calma)
        # z=round(z*100.)+1.
        # N =2000.
        # v=(raioCrista-raioVale)
        # ndepassos=NZ
        # passo=Lb/(ndepassos)
        # x = [0:passo:Lb] #(O que isso faz em matlab?)
        # f = 0.034+v/2+zeros(1,ndepassos+1)
        # for i = 1:2:N
        #  a =2*v/np.pi/i
        #  f = f-a*sin(13*pi*i*x)
        # f(1)=f(2)
        # f(ndepassos+1)=f(ndepassos)
        # raioInterno=f(z)

        Xri = raioInterno * np.cos(tetano)
        Yri = raioInterno * np.sin(tetano)

        return raioInterno, Xri, Yri

    def MontaMatriz(self):
        # Criando matriz e vetor de zeros:
        M = np.zeros([self.NTOTAL, self.NTOTAL])
        f = np.zeros([self.NTOTAL, 1])

        # Aplicando as condições de contorno em Z=0 e Z=L:
        cont = 0
        for x in range(self.NTETA):
            M[cont][cont] = 1
            f[cont][0] = self.Pent
            cont = cont + self.NZ - 1
            M[cont][cont] = 1
            f[cont][0] = self.Ps
            cont = cont + 1

        # Aplicando as condições de contorno p(TETA=0)=P(TETA=pi):
        cont = 0;
        for x in range(self.NZ - 2):
            M[self.NTOTAL - self.NZ + 1 + cont][1 + cont] = 1
            M[self.NTOTAL - self.NZ + 1 + cont][self.NTOTAL - self.NZ + 1 + cont] = -1
            cont = cont + 1

        # Nós da fronteira com condição de contorno periódica:
        cont = 1
        j = 0
        for i in range(1, self.NZ - 1):
            a = (1 / self.DTETA ** 2) * (self.C1[i][self.NTETA - 1])
            M[cont][self.NTOTAL - 2 * self.NZ + cont] = a
            b = (1 / self.DZ ** 2) * (self.C2[i - 1, j])
            M[cont][cont - 1] = b
            c = -((1 / self.DTETA ** 2) * ((self.C1[i][j]) + self.C1[i][self.NTETA - 1]) + (1 / self.DZ ** 2) * (self.C2[i][j] + self.C2[i - 1][j]))
            M[cont, cont] = c
            d = (1 / self.DZ ** 2) * (self.C2[i][j])
            M[cont][cont + 1] = d
            e = (1 / self.DTETA ** 2) * (self.C1[i][j])
            M[cont][cont + self.NZ] = e
            cont = cont + 1

        # Nós internos:
        cont = self.NZ + 1
        for j in range(1, self.NTETA - 1):
            for i in range(1, self.NZ - 1):
                a = (1 / self.DTETA ** 2) * (self.C1[i, j - 1])
                M[cont][cont - self.NZ] = a
                b = (1 / self.DZ ** 2) * (self.C2[i - 1][j])
                M[cont][cont - 1] = b
                c = -((1 / self.DTETA ** 2) * ((self.C1[i][j]) + self.C1[i][j - 1]) + (1 / self.DZ ** 2) * (self.C2[i][j] + self.C2[i - 1][j]))
                M[cont, cont] = c
                d = (1 / self.DZ ** 2) * (self.C2[i][j])
                M[cont][cont + 1] = d
                e = (1 / self.DTETA ** 2) * (self.C1[i][j])
                M[cont][cont + self.NZ] = e
                cont = cont + 1
            cont = cont + 2

        # Montando o vetor f:
        cont = 1
        for j in range(self.NTETA - 1):
            for i in range(1, self.NZ - 1):
                if j == 0:
                    l = ((self.C0W[i][j] - self.C0W[i][self.NTETA - 1]) / (self.DTETA))
                    f[cont][0] = l
                else:
                    l = ((self.C0W[i, j] - self.C0W[i, j - 1]) / (self.DTETA))
                    f[cont][0] = l
                cont = cont + 1
            cont = cont + 2

        return M, f

    def ResolveMatriz(self, M, f):
        P = np.linalg.solve(M, f)
        return P

        # print(P)

        # ==========================================================================
        # Pmatriz
        # Cria a matriz das pressões
        # ==========================================================================

    def Pmatriz(self, P):
        Pmat = np.zeros([self.NZ, self.NTETA])
        for i in range(self.NZ):
            for j in range(self.NTETA):
                k = (j) * self.NZ + (i)
                Pmat[i][j] = P[k]
        return Pmat
